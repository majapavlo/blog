{
  
    
        "post0": {
            "title": "Customer Lifetime Value Prediction using a Deep Probabilistic Neural Network",
            "content": "About . Predicting a customer’s lifetime value (LTV) can be quite a challenging task. Wang, Liu and Miao propose using a neural network with a mixture loss to handle the intricacies of churn and lifetime value modelling of new customers. . In this blogpost we’ll take a look at their proposed solution and go through the reasoning behind their ideas. The first section briefly summarises the importance and challenges of lifetime value modelling. It also looks at how Wang, Liu and Miao tackle these problems and quickly runs through the results of their paper. The second section then takes a deeper look at their chosen architecture, specifically the output layer. Lastly, the final section goes through the proposed loss function in more detail. . This post is not intended to be an in-depth mathematical explanation; but rather, is meant to provide a high-level, more approachable explanation of the paper. . Paper Overview . Why are lifetime value and churn important? Having accurate insights into customers’ future purchase behaviour can support a variety of operational and strategic business activities. For example, it can help companies with customer retention by segmenting customers according to their LTV, and targeting specific customer segments with different offers and loyalty schemes, resulting in more efficient resource spending. . Figure 1 shows a typical skewed LTV distribution. The large count at LTV=0 shows the huge proportion of customers who have churned (they bought a product once and then never returned). To visualise the returning customers a bit better the x-axis is displayed as the logarithm of (LTV+1). This shows that the range between returning customers’ lifetime spend varies considerably. A small proportion of high spenders can sometimes account for a large amount of business revenue. This distribution with a large proportion of one-time spenders and a few rather huge spenders poses a challenge to the traditional mean-squared-error approach. You will see this in more detail in the section that dives into their loss function below. . . Commonly, LTV and churn modelling is done separately (figure 2, left). Wang, Liu and Miao’s approach, however, allows them to tackle Churn and LTV prediction simultaneously (figure 2, right). . . Instead of looking at the LTV and Churn distributions separately, they propose using “a mixture of zero-point mass and a lognormal distribution”, calling it the zero-inflated lognormal distribution (ZILN). They then derive a mixture loss by taking the negative log-likelihood of that ZILN distribution and then use it to train their neural network on both tasks simultaneously. Too much information? Don’t worry about it. We will look at what loss functions are and how the ZILN works in more detail below. What you should take away for now is that you can use one model to predict the two tasks: Churn and LTV. . Wang, Liu and Miao measure the performance of their approach on the two subtasks. While the Churn prediction achieves a comparable performance with a classical binary classification loss, their LTV prediction task outperforms the traditional mean-squared-error (MSE) approach on three different evaluation metrics. We won’t dissect their evaluation metrics in this post, but you can take a look at their paper if you’d like to understand their results more. . Deep Dive: Architecture &#8212; Output Layer . As mentioned above Wang, Liu and Miao use a neural network for their model. They opt for a simple feed-forward neural network with 64 units on the first hidden layer and 32 on the second. See the figure 3 below. These hidden units use the ReLu activation function. Numerical inputs are fed in directly, while categorical inputs are encoded as embeddings. We will focus on the output layer as these units are interesting to the loss function that we will discuss below. . . The output layer has one unit p to predict the probability of someone having churned or not. The activation function used to represent that probability is a sigmoid function. This function works well for outputting probabilities as its range of output values is between 0 and 1. A typical threshold is 0.5. A prediction that is below 0.5 will be a customer who’s still alive, while those with a prediction above 0.5 will be predicted as churned. See figure 4 below. . . LTV on the other hand needs two units. One unit to predict a location parameter μ and another unit to predict the scale parameter σ. We then use these two parameters to define a full prediction distribution, which in turn provides us with an uncertainty measure connected to our prediction (the uncertainty can be estimated by using the quantiles of our predicted distribution). These two outputs μ and σ should not be mistaken with the more familiar mean and standard deviation from a normal distribution. . The μ unit has no constraints in terms of range or sign. Thus, Wang, Liu and Miao opted to use an identity function for μ. This means it simply outputs the predicted value of the neural networks μ unit without running it through an activation function. . The scale parameter σ should only be able to return positive outputs. A common function like the exponential can solve this positivity constraint, but due to its steep growth can easily result in exploding gradients. Wang, Liu and Miao opted for a softplus activation function which doesn’t grow as steeply as the exponential function. However, the softplus alone didn’t seem enough to avoid this instability when training their model so they also applied gradient clipping. . . The output layer then ends up looking like figure 6 below. Churn just needs one probability value p, whereas LTV has both μ and σ. By learning to represent multiple tasks (both Churn and LTV) using one model, the middle layers of this network learn to generalise better on each subtask. If you want to understand more about this, have a read on multi-task learning here. . . Deep Dive: ZILN Loss . To train this network we minimise the error between the neural network’s predictions and the actual target value from the data. In our example this means we compare our predicted churn probability to the actual churn value. This performance measure is called the loss. . Depending on what you are trying to achieve, you use a different loss function that you optimise your neural network against. Given that the architecture above combines two tasks we will need a loss function that is tailored to each subtask. . Two common loss functions are Binary Cross Entropy (BCE) loss and Mean Squared Error (MSE) loss. BCE is used for binary classification tasks where you are trying to predict if something is true or false; meaning there are only two states. In our case that would be whether someone has churned or not. Then there is MSE which is a commonly used loss for regression problems where you are trying to predict a continuous value such as a salary, stocks or in our case LTV. . Binary Cross Entropy (BCE) Loss &#8212; Churn . For the churn task of the neural network Wang, Liu and Miao use the BCE loss: . $$BCE Loss = - frac{1}{N} sum_{i=1}^{N} -(y_i*log(p_i) + (1-y_i) * log(1-p_i))$$ yᵢ is the true target value (1 for churn and 0 for no churn), pᵢ is the predicted probability of yᵢ =churn while (1-pᵢ) is the exact opposite (no churn) . The aim in our case is to correctly classify churn (class 1) and no churn (class 0). We need a way to handle both classes in one function and put a higher penalty on wrong predictions. This is achieved by activating only one part of the loss function, while keeping the other part deactivated. Giving wrong predictions a much higher error is achieved by using the logarithm. Let’s look at an example to clarify this. . To keep it simple, we will just look at one observation where we have the true observation belonging to class 1 (churn, y₁=1), this removes the summation, and we are left with: . $$error_1 = -(y_i*log(p_i) + (1-y_i) * log(1-p_i))$$ . Now let’s say our model predicts this observation to be churn with a probability of 0.95 (p₁=0.95). That means that we get the following error for our observation: . $$error_1 = -(1*log(0.95) + (1-1) * log(1-0.95))$$ $$ = -(1*log(0.95) + 0 * log(0.05))$$ $$ = -(1*log(0.95))$$ $$ approx 0.051 $$ . This shows that only the first part of the equation is activated, the other part (multiplying by 0) cancels out. So, we are left with the log() of our probability which gives us tiny loss values when pᵢ is close to 1 and gets larger and larger the closer our probability gets to the value of 0 (as in us predicting the wrong class), see figure 8 (left) below. In our example we have a probability of 0.95 and therefore end up with a small error value of 0.051 for our observation. If instead, our true value is now 0 instead of 1, then the other part of the loss function activates, and we end up having a large error of 2.966 if we are still predicting that it is churn (=1) with a probability of 0.95, see figure 9 (right) below. . . This example is summarised in the first 2 rows of table 1 below. The table, additionally, shows how the loss function behaves in the opposite scenario where the predicted value is 0 with pᵢ=0.01. . . This example should give you a general idea why BCE works well for tasks where you are predicting either one class or the other. Having such a large error on wrong predictions will force the model to learn a better representation which should minimise the overall error in your model’s prediction performance. . L . Zero-Inflated-Lognormal (ZILN) Loss &#8212; Churn &amp; LTV together . Now that we’ve looked at the different tasks individually the final step to getting the ZILN mixture loss is straight-forward. It is simply a linear combination of the two losses from above. See figure 11 below. . . Wang, Liu and Miao assume an equal weighting for each subtask, so the loss function ends up looking as follows: . $$ ZILN Loss = MSE Loss + Lognormal Loss$$ . This means we end up training the neural network by simply minimising the sum of the two loss functions (BCE and Lognormal loss). . Summary . In this blog post you had a look at the paper: A Deep Probabilistic Model for Customer Lifetime Value Prediction, which proposes a multi-task approach to LTV modelling. You explored their proposed output units and the associated BCE and lognormal loss functions that when combined, result in their proposed ZILN loss. The benefits of this approach are: . Having an LTV prediction distribution instead of a single point prediction (which gives you insights into the uncertainty of your predictions) | Better generalisation on both churn and LTV modelling, due to the multitask learning approach | Reduction of the engineering effort around, building, training and maintaining two separate models | . What this post didn’t cover is how the results compare to other models or how to apply this model to a use case. Given that their code is available online you should be able to use it as is for modelling new customers’ expectations or adapt it to model the lifetime over time using a sequential neural network architecture such as an RNN or LSTM. . Footnotes . ¹ For all losses to start at the same minimum y-value the minimum of each loss itself was subtracted, which is why the y-axis values differ to the direct loss calculations from the table above. . ² The figure in the paper looks like it has been scaled on each of the loss functions to show the effect of shift in a clearer way .",
            "url": "https://majapavlo.github.io/blog/jupyter/2022/01/02/ltv.html",
            "relUrl": "/jupyter/2022/01/02/ltv.html",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "test .",
            "url": "https://majapavlo.github.io/blog/jupyter/2021/01/01/test.html",
            "relUrl": "/jupyter/2021/01/01/test.html",
            "date": " • Jan 1, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://majapavlo.github.io/blog/2020/01/14/test-markdown-post.html",
            "relUrl": "/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  

  

  

  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page13": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://majapavlo.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}