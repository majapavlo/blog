{
  
    
        "post0": {
            "title": "Lognormal Distribution – A simple explanation",
            "content": "About . We will briefly look at the definition of the log-normal and then go onto calculate the distribution’s parameters μ and σ from simple data. We will then have a look at how to calculate the mean, mode, median and variance from this probability distribution. . Informal Definition . The log-normal distribution is a right skewed continuous probability distribution, meaning it has a long tail towards the right. It is used for modelling various natural phenomena such as income distributions, the length of chess games or the time to repair a maintainable system and more. . . The probability density function for the log-normal is defined by the two parameters μ and σ, where x &gt; 0: . $$f(x) = frac{1}{x sigma sqrt{2 pi}} e^{- frac{1}{2} left( frac{ln x - mu}{ sigma} right)^2 }$$ . μ is the location parameter and σ the scale parameter of the distribution. Caution here! These two parameters should not be mistaken for the more familiar mean or standard deviation from a normal distribution. When our log-normal data is transformed using logarithms our μ can then be viewed as the mean (of the transformed data) and σ as the standard deviation (of the transformed data). But without these transformations μ and σ here are simply two parameters that define our log-normal, not the mean or standard deviation! Okay, now we went from “let’s keep it easy” to “a little too much information”. Let’s dial back and have a look at the just mentioned relationship between the log-normal and normal distribution a bit more. . The name of the “log-normal” distribution reveals that it relates to logarithms as well as the normal distribution. How? Let’s say your data fits a log-normal distribution. If you then take the logarithm of all your data points, the newly transformed points will now fit a normal distribution. This simply means that when you take the log of your log-normal data you end up with a normal distribution. See figure below. . . The data points for our log-normal distribution are given by the $X$ variable. When we log-transform that $X$ variable $(Y=ln(X))$ we get a Y variable which is normally distributed. . We can reverse this thinking and look at $Y$ instead. If $Y$ has a normal distribution and we take the exponential of $Y$ $(X=exp(Y))$, then we get back to our $X$ variable, which has a log-normal distribution. This visual is helpful to keep in mind when analysing important properties of the log-normal distribution: . “The most efficient way to analyse log-normally distributed data consists of applying the well-known methods based on the normal distribution to logarithmically transformed data and then to back-transform results if appropriate.” Lognormal wiki . Estimate &#956; &amp; &#963; from data . We can estimate our log-normal parameters μ and σ using maximum likelihood estimation (MLE). This is a popular approach for approximating distribution parameters as it finds parameters that make our assumed probability distribution ‘most likely’ for our observed data. . If you want to understand how MLE works in more detail, StatQuest explains the approach in a fun intuitive way and also derives the estimators for the normal distribution. . The maximum likelihood estimators for the normal distribution are: . $$ hat mu = frac{ sum_{i} x_i}{n}$$ . $$ hat sigma^2 = frac{ sum_{i} left( x_i - hat mu right)^2 }{n}$$ . We, however, want the maximum likelihood estimators μ and σ for the log-normal distribution, which are: . $$ hat mu = frac{ sum_{k} ln (x_k)}{n}$$ $$ hat sigma^2 = frac{ sum_{k} left(ln (x_k) - hat mu right)^2 }{n}$$ . These formulas are near identical. We can see that we can use the same approach as with the normal distribution and just transform our data with a logarithm first. If you are curious about how we get our log-normal estimators here is a link to the derivation. . Where is the simple example?! . Let’s take a look at 5 values of income that follow a log-normal distribution. Our fictitious person 1 earns 20k, person 2 earns 22k and so on: . Person 1 Person 2 Person 3 Person 4 Person 5 . 20 | 22 | 25 | 30 | 60 | . We can now estimate μ with the logic from above. First, we take the log of each of our income data points and then calculate the average value for the 5 transformed data points, see below: . Income ln(Income) . 20 | 2.9957 | . 22 | 3.0910 | . 25 | 3.2188 | . 30 | 3.4011 | . 60 | 4.0943 | . . $$ hat mu = frac{2.9957+3.0910+3.2188+3.4011+4.0943}{5} approx 3.36$$ . This gives us a value of 3.36 for our location parameter μ. . . We can then use our estimated μ to approximate our σ with the following formula. . $$ hat sigma = sqrt{ frac{ sum_{k} left(ln (x_k) - hat mu right)^2 }{n-1}}$$ . Rather than calculating σ², we take the square root of the formula above to approximate σ. The formula also uses n-1 instead of just n to get a less biased estimator. If you want to understand more on this change have a look at corrected sample variance (or also Bessel’s correction). . μ__ with the logic from above. First, we take the log of each of our income data points and then calculate the average value for the 5 transformed data points, see below: . $Income$ $ln(Income)$ $μ$ $(ln(Income)-μ)$ $(ln(Income)-μ)^2$ . 20 | 2.9957 | 3.36 | -0.3643 | 0.7343 | . 22 | 3.0910 | 3.36 | -0.269 | 0.0723 | . 25 | 3.2188 | 3.36 | -0.1412 | 0.0199 | . 30 | 3.4011 | 3.36 | 0.0411 | 0.0017 | . 60 | 4.0943 | 3.36 | 0.7343 | 0.5393 | . . Similar to above, the first step is to take the logarithm of each individual income data point. We then subtract the estimated μ from each log-transformed data point and then square each result. See table above. These values are then inserted into the formula from above: . $$ hat sigma = sqrt{ frac{(ln(20)-3.36)^2 + (ln(22)-3.36)^2 + (ln(25)-3.36)^2 + (ln(30)-3.36)^2 + (ln(60)-3.36)^2}{5-1}} approx 0.4376$$ . $$ hat sigma = sqrt{ frac{0.1327+0.0724+0.0199+0.0017+0.5393}{5-1}} approx 0.4376$$ . This gives us a value of 0.4376 for our scale parameter σ. . Note: These calculations are just an example of how these values can be obtained. You need more values to have any statistical significance. . Calculate median, mean, mode &amp; variance . Extracting some of the important properties of the log-normal distribution is straightforward once we have our parameters μ and σ. See key properties, their formula, and the calculation for our example data in the table and figure below. . . How do we arrive at the different formulas in the table above? . The median is derived by taking the log-normal cumulative distribution function, setting it to 0.5 and then solving this equation (see here). | The mode represents the global maximum of the distribution and can therefore be derived by taking the derivative of the log-normal probability density function and solving it for 0 (see here). | The mean (also known as the expected value) of the log-normal distribution is the probability-weighted average over all possible values (see here). | The variance of the log-normal distribution is the probability-weighted average of the squared deviation from the mean (see here). | . . References . [1] Wikipedia, Log-Normal Distribution (2022), retrieved on 2022–02–06 . [2] M. Taboga, “Log-normal distribution”, Lectures on probability theory and mathematical statistics (2021), Kindle Direct Publishing. Online appendix. . [3] A. Katz, C. Williams, and J. Khim, Brilliant: Log-normal Distribution (2022), retrieved on 2022–02–06 . [4] J. Soch, K. Petrykowski, T. Faulkenberry, The Book of Statistical Proofs (2021), github.io . [5] Wikipedia, Bessel’s Correction (2022), retrieved on 2022–02–06 .",
            "url": "https://majapavlo.github.io/blog/lognormal/distribution/2022/02/05/lognormal_dist.html",
            "relUrl": "/lognormal/distribution/2022/02/05/lognormal_dist.html",
            "date": " • Feb 5, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Formulas & proofs for the Log-normal Distribution",
            "content": "Obtaining the log-normal maximum likelihood estimators . We start with the likelihood function which is: . . We then take the natural log of the likelihood function (helps simplify our calculations). . . To find the μ and σ which maximise our log-likelihood function we take the gradient of our log-likelihood function with respect to μ and σ and set it to 0. . . To prove that these two estimators maximise our log-likelihood function we confirm that the Hessian matrix is negative-definite. We won’t look into these steps here. . ... . Obtaining the mode . The mode is the value that maximises the probability density function (pdf). We, therefore, take the gradient with respect to x and set it equal to 0. . . Obtaining the median . erf is the error function. The median is the value where the cumulative distribution function (cdf) is 0.5. . . References: . [1] Wikipedia, Maximum Likelihood Estimation (2022), retrieved on 2022–02–06 . [2] J. Soch, K. Petrykowski, T. Faulkenberry, The Book of Statistical Proofs (2021), github.io . [3] Mdoc, Mode of lognormal distribution (2022), retrieved on 2022–02–04, Mathematics Stack Exchange, URL (version: 2015–06–11) .",
            "url": "https://majapavlo.github.io/blog/2022/02/02/lognorm_formulas.html",
            "relUrl": "/2022/02/02/lognorm_formulas.html",
            "date": " • Feb 2, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Customer Lifetime Value Prediction using a Deep Probabilistic Neural Network",
            "content": "About . Predicting a customer’s lifetime value (LTV) can be quite a challenging task. Wang, Liu and Miao propose using a neural network with a mixture loss to handle the intricacies of churn and lifetime value modelling of new customers. . In this blogpost we’ll take a look at their proposed solution and go through the reasoning behind their ideas. The first section briefly summarises the importance and challenges of lifetime value modelling. It also looks at how Wang, Liu and Miao tackle these problems and quickly runs through the results of their paper. The second section then takes a deeper look at their chosen architecture, specifically the output layer. Lastly, the final section goes through the proposed loss function in more detail. . This post is not intended to be an in-depth mathematical explanation; but rather, is meant to provide a high-level, more approachable explanation of the paper. . Paper Overview . Why are lifetime value and churn important? Having accurate insights into customers’ future purchase behaviour can support a variety of operational and strategic business activities. For example, it can help companies with customer retention by segmenting customers according to their LTV, and targeting specific customer segments with different offers and loyalty schemes, resulting in more efficient resource spending. . Figure 1 shows a typical skewed LTV distribution. The large count at LTV=0 shows the huge proportion of customers who have churned (they bought a product once and then never returned). To visualise the returning customers a bit better the x-axis is displayed as the logarithm of (LTV+1). This shows that the range between returning customers’ lifetime spend varies considerably. A small proportion of high spenders can sometimes account for a large amount of business revenue. This distribution with a large proportion of one-time spenders and a few rather huge spenders poses a challenge to the traditional mean-squared-error approach. You will see this in more detail in the section that dives into their loss function below. . . Commonly, LTV and churn modelling is done separately (figure 2, left). Wang, Liu and Miao’s approach, however, allows them to tackle Churn and LTV prediction simultaneously (figure 2, right). . . Instead of looking at the LTV and Churn distributions separately, they propose using “a mixture of zero-point mass and a lognormal distribution”, calling it the zero-inflated lognormal distribution (ZILN). They then derive a mixture loss by taking the negative log-likelihood of that ZILN distribution and then use it to train their neural network on both tasks simultaneously. Too much information? Don’t worry about it. We will look at what loss functions are and how the ZILN works in more detail below. What you should take away for now is that you can use one model to predict the two tasks: Churn and LTV. . Wang, Liu and Miao measure the performance of their approach on the two subtasks. While the Churn prediction achieves a comparable performance with a classical binary classification loss, their LTV prediction task outperforms the traditional mean-squared-error (MSE) approach on three different evaluation metrics. We won’t dissect their evaluation metrics in this post, but you can take a look at their paper if you’d like to understand their results more. . Deep Dive: Architecture &#8212; Output Layer . As mentioned above Wang, Liu and Miao use a neural network for their model. They opt for a simple feed-forward neural network with 64 units on the first hidden layer and 32 on the second. See the figure 3 below. These hidden units use the ReLu activation function. Numerical inputs are fed in directly, while categorical inputs are encoded as embeddings. We will focus on the output layer as these units are interesting to the loss function that we will discuss below. . . The output layer has one unit p to predict the probability of someone having churned or not. The activation function used to represent that probability is a sigmoid function. This function works well for outputting probabilities as its range of output values is between 0 and 1. A typical threshold is 0.5. A prediction that is below 0.5 will be a customer who’s still alive, while those with a prediction above 0.5 will be predicted as churned. See figure 4 below. . . LTV on the other hand needs two units. One unit to predict a location parameter μ and another unit to predict the scale parameter σ. We then use these two parameters to define a full prediction distribution, which in turn provides us with an uncertainty measure connected to our prediction (the uncertainty can be estimated by using the quantiles of our predicted distribution). These two outputs μ and σ should not be mistaken with the more familiar mean and standard deviation from a normal distribution. . The μ unit has no constraints in terms of range or sign. Thus, Wang, Liu and Miao opted to use an identity function for μ. This means it simply outputs the predicted value of the neural networks μ unit without running it through an activation function. . The scale parameter σ should only be able to return positive outputs. A common function like the exponential can solve this positivity constraint, but due to its steep growth can easily result in exploding gradients. Wang, Liu and Miao opted for a softplus activation function which doesn’t grow as steeply as the exponential function. However, the softplus alone didn’t seem enough to avoid this instability when training their model so they also applied gradient clipping. . . The output layer then ends up looking like figure 6 below. Churn just needs one probability value p, whereas LTV has both μ and σ. By learning to represent multiple tasks (both Churn and LTV) using one model, the middle layers of this network learn to generalise better on each subtask. If you want to understand more about this, have a read on multi-task learning here. . . Deep Dive: ZILN Loss . To train this network we minimise the error between the neural network’s predictions and the actual target value from the data. In our example this means we compare our predicted churn probability to the actual churn value. This performance measure is called the loss. . Depending on what you are trying to achieve, you use a different loss function that you optimise your neural network against. Given that the architecture above combines two tasks we will need a loss function that is tailored to each subtask. . Two common loss functions are Binary Cross Entropy (BCE) loss and Mean Squared Error (MSE) loss. BCE is used for binary classification tasks where you are trying to predict if something is true or false; meaning there are only two states. In our case that would be whether someone has churned or not. Then there is MSE which is a commonly used loss for regression problems where you are trying to predict a continuous value such as a salary, stocks or in our case LTV. . Binary Cross Entropy (BCE) Loss &#8212; Churn . For the churn task of the neural network Wang, Liu and Miao use the BCE loss: . $$BCE Loss = - frac{1}{N} sum_{i=1}^{N} -(y_i*log(p_i) + (1-y_i) * log(1-p_i))$$ yᵢ is the true target value (1 for churn and 0 for no churn), pᵢ is the predicted probability of yᵢ =churn while (1-pᵢ) is the exact opposite (no churn) . The aim in our case is to correctly classify churn (class 1) and no churn (class 0). We need a way to handle both classes in one function and put a higher penalty on wrong predictions. This is achieved by activating only one part of the loss function, while keeping the other part deactivated. Giving wrong predictions a much higher error is achieved by using the logarithm. Let’s look at an example to clarify this. . To keep it simple, we will just look at one observation where we have the true observation belonging to class 1 (churn, y₁=1), this removes the summation, and we are left with: . $$error_1 = -(y_i*log(p_i) + (1-y_i) * log(1-p_i))$$ . Now let’s say our model predicts this observation to be churn with a probability of 0.95 (p₁=0.95). That means that we get the following error for our observation: . $$error_1 = -(1*log(0.95) + (1-1) * log(1-0.95))$$ $$ = -(1*log(0.95) + 0 * log(0.05))$$ $$ = -(1*log(0.95))$$ $$ approx 0.051 $$ . This shows that only the first part of the equation is activated, the other part (multiplying by 0) cancels out. So, we are left with the log() of our probability which gives us tiny loss values when pᵢ is close to 1 and gets larger and larger the closer our probability gets to the value of 0 (as in us predicting the wrong class), see figure 8 (left) below. In our example we have a probability of 0.95 and therefore end up with a small error value of 0.051 for our observation. If instead, our true value is now 0 instead of 1, then the other part of the loss function activates, and we end up having a large error of 2.966 if we are still predicting that it is churn (=1) with a probability of 0.95, see figure 9 (right) below. . . This example is summarised in the first 2 rows of table 1 below. The table, additionally, shows how the loss function behaves in the opposite scenario where the predicted value is 0 with pᵢ=0.01. . . This example should give you a general idea why BCE works well for tasks where you are predicting either one class or the other. Having such a large error on wrong predictions will force the model to learn a better representation which should minimise the overall error in your model’s prediction performance. . Lognormal Loss &#8212; LTV . As mentioned above, rather than predicting a single point estimate for the LTV task of the network it is preferable to have a full prediction distribution. The distribution can give us an idea about the spread of observation points around our predicted LTV value. Wang, Liu and Miao propose using the lognormal distribution. The two parameters μ and σ from above describe the distribution’s probability density function (PDF): $ PDF = frac{1}{x sigma sqrt{2 pi}} exp left( - frac{( log x - mu)^2}{2 sigma^2} right) $ See figure 8 below. This lognormal distribution resembles typical LTV data quite well: it is right-skewed, starting at zero and going into positive infinity. Hence, it makes sense for the neural network to learn the parameters of the lognormal distribution. . . We can obtain the lognormal loss by taking the negative log-likelihood of the lognormal distribution, see the loss function below. We won’t go through the steps of deriving the loss. The main idea is to simply compare the lognormal loss to the classic MSE loss and see how it behaves differently to the MSE. . $$ Lognormal Loss = frac{1}{N} sum_{i=1}^{N} log(x_i sigma sqrt{2 pi}) + frac{( log x_i - mu)^2}{2 sigma^2}$$ xᵢ is our actual true value, μ &amp; σ are the estimated parameters for the lognormal probability distribution, N is the number of samples . Versus the MSE loss: $$ MSE Loss = frac{1}{N} sum_{i=1}^{N} (x_i - hat{x_i})^2 $$ xᵢ is our actual true value and xᵢ is the predicted value, N is the number of samples . Let’s look at a few examples. The first example will show us how these losses differ on small and large prediction values. The second example will show us how they differ when predictions are over- or under-estimated. . Lognormal takes more of a relative look . We have a case where our true median value of the lognormal distribution is 20 and another case where this true value is 20,000. The table below compares the MSE loss to the Lognormal loss (with two different σ² values). We can see that the MSE penalises high spenders (case 2, loss: 16,000,000) more harshly compared to lower spenders (case 1, loss: 16). The loss in case 2 is 1,000,000 times larger than for case 1, despite the relative deviation from the true value being the same. . . Given that a high-value customer typically spends orders of magnitude more than a normal customer, the MSE is less suited for this problem. It would over-penalise the prediction errors for our high value customers. The Lognormal on the other hand will treat small differences from the average spending customer almost the same as large differences from high-value customer predictions. . Lognormal penalises underestimates more than overestimates . Here both cases have a true value of 20, but in case 1 we under-predict by 6, whereas in case 2 we over-predict by 6. The table below compares the different losses on both cases again. We can see that the MSE penalises underestimates and overestimates equally, while the lognormal loss penalises underestimates more than overestimates. . . This asymmetric behaviour is visualised in the figure 9 below1. While the MSE is symmetrical around the minimum, it shows that the lognormal loss gets more asymmetric as σ² increases. . . So far, we’ve looked at the loss function in terms of its median. The median is defined as exp(μ), meaning we used μ=log(x) in the loss function. Wang, Liu and Miao, however, suggest predicting LTV as the mean of the lognormal distribution, which is: . $$ E(X) = exp left( mu + frac{ sigma^2}{2} right)$$ . This means we substitute μ with $ log(x) - frac{σ²}{2}$ in the loss function. The loss still behaves in the same way as above. The only difference this creates is a bias in our predictions towards a higher number. The higher σ² the higher our predicted LTV will be. If for instance our true value is 20, and we perfectly predict the μ-unit but have a σ² of 0.3, then our predicted LTV will be about 23.2. The same value with a σ² of only 0.01 would give us an LTV prediction of about 20.1 (much closer to our true value). We can see the shift in minimum prediction in the figure 10 below2. . . Both the mean and median are viable approaches when using the lognormal. But when do we use the lognormal instead of the MSE? The lognormal loss should be considered more favourable to the MSE when the range of our true values (LTV) is large as we don’t want large values to be penalised more. . Zero-Inflated-Lognormal (ZILN) Loss &#8212; Churn &amp; LTV together . Now that we’ve looked at the different tasks individually the final step to getting the ZILN mixture loss is straight-forward. It is simply a linear combination of the two losses from above. See figure 11 below. . . Wang, Liu and Miao assume an equal weighting for each subtask, so the loss function ends up looking as follows: . $$ ZILN Loss = BCE Loss + Lognormal Loss$$ . This means we end up training the neural network by simply minimising the sum of the two loss functions (BCE and Lognormal loss). . Summary . In this blog post you had a look at the paper: A Deep Probabilistic Model for Customer Lifetime Value Prediction, which proposes a multi-task approach to LTV modelling. You explored their proposed output units and the associated BCE and lognormal loss functions that when combined, result in their proposed ZILN loss. The benefits of this approach are: . Having an LTV prediction distribution instead of a single point prediction (which gives you insights into the uncertainty of your predictions) | Better generalisation on both churn and LTV modelling, due to the multitask learning approach | Reduction of the engineering effort around, building, training and maintaining two separate models | . What this post didn’t cover is how the results compare to other models or how to apply this model to a use case. Given that their code is available online you should be able to use it as is for modelling new customers’ expectations or adapt it to model the lifetime over time using a sequential neural network architecture such as an RNN or LSTM. . . Footnotes . 1. For all losses to start at the same minimum y-value the minimum of each loss itself was subtracted, which is why the y-axis values differ to the direct loss calculations from the table above.↩ . 2. The figure in the paper looks like it has been scaled on each of the loss functions to show the effect of shift in a clearer way↩ .",
            "url": "https://majapavlo.github.io/blog/probabilistic/neural%20network/loss%20function/2022/01/02/ltv.html",
            "relUrl": "/probabilistic/neural%20network/loss%20function/2022/01/02/ltv.html",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "test .",
            "url": "https://majapavlo.github.io/blog/2021/01/01/hide_example.html",
            "relUrl": "/2021/01/01/hide_example.html",
            "date": " • Jan 1, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://majapavlo.github.io/blog/2020/01/14/test-markdown-post.html",
            "relUrl": "/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  

  

  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://majapavlo.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}